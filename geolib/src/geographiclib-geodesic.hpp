/**
 * @file geographiclib-geodesic.hpp
 * The functions below are part of the
 * GeographicLib library
 * https://geographiclib.sourceforge.io
 */

#include "geographiclib-bitmask.hpp"

#define GEOGRAPHICLIB_GEODESIC_ORDER 7

static const int nC4_ = GEOGRAPHICLIB_GEODESIC_ORDER;
static const int nC4x_ = (nC4_ * (nC4_ + 1)) / 2;
static int nC3_ = GEOGRAPHICLIB_GEODESIC_ORDER;
static double _C3x[GEOGRAPHICLIB_GEODESIC_ORDER];
static double _C4x[nC4x_];
static int nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;

double eatanhe(double x, double es)  {
  return es > double(0) ? es * std::atanh(es * x) : -es * std::atan(es * x);
}

static double polyval(int N, const double p[], double x)
// This used to employ fma; but that's too slow and it seemed not to
// improve the accuracy noticeably.  This might change when there's direct
// hardware support for fma.
{ double y = N < 0 ? 0 : *p++; while (--N >= 0) y = y * x + *p++; return y; }

double A3f(double eps) {
  // Evaluate A3
  int nA3_ = GEOGRAPHICLIB_GEODESIC_ORDER; double _A3x[nA3_];
  return polyval(nA3_ - 1, _A3x, eps);
}

template<typename T> static T sq(T x)
{ return x * x; }

template<typename T> static void norm(T& x, T& y)
{ T h = hypot(x, y); x /= h; y /= h; }

static double pi() {
  using std::atan2;
  static const double pi = atan2(double(0), double(-1));
  return pi;
}

void C3f(double eps, double c[]) {
  // Evaluate C3 coeffs
  // Elements c[1] thru c[nC3_ - 1] are set
  double mult = 1;
  int o = 0;
  for (int l = 1; l < nC3_; ++l) { // l is index of C3[l]
    int m = nC3_ - l - 1;          // order of polynomial in eps
    mult *= eps;
    c[l] = mult * polyval(m, _C3x + o, eps);
    o += m + 1;
  }
  // Post condition: o == nC3x_
}

void C4f(double eps, double c[]) {
  // Evaluate C4 coeffs
  // Elements c[0] thru c[nC4_ - 1] are set
  double mult = 1;
  int o = 0;
  for (int l = 0; l < nC4_; ++l) { // l is index of C4[l]
    int m = nC4_ - l - 1;          // order of polynomial in eps
    c[l] = mult * polyval(m, _C4x + o, eps);
    o += m + 1;
    mult *= eps;
  }
  // Post condition: o == nC4x_
}

/**
* Normalize a latitude.
**/
static double LatFix(double x)
{
    using std::abs; return abs(x) > 90 ? std::numeric_limits<double>::quiet_NaN() : x;
}

double degree() {
  static const double degree = pi() / 180;
  return degree;
}

static void sincosd(double x, double& sinx, double& cosx) {
  // In order to minimize round-off errors, this function exactly reduces
  // the argument to the range [-45, 45] before converting it to radians.
  using std::sin; using std::cos;
  double r; int q;

  // Possible bug.
  using std::remquo;
  r = remquo(x, double(90), &q);

  // now abs(r) <= 45
  r *= degree();
  // Possibly could call the gnu extension sincos
  double s = sin(r), c = cos(r);

  switch (unsigned(q) & 3U) {
  case 0U: sinx =  s; cosx =  c; break;
  case 1U: sinx =  c; cosx = -s; break;
  case 2U: sinx = -s; cosx = -c; break;
  default: sinx = -c; cosx =  s; break; // case 3U
  }
  // Set sign of 0 results.  -0 only produced for sin(-0)
  if (x != 0) { sinx += double(0); cosx += double(0); }
}

double sum(double u, double v, double& t) {
  double s = u + v;
  double up = s - v;
  double vpp = s - up;
  up -= u;
  vpp -= v;
  t = -(up + vpp);
  // u + v =       s      + t
  //       = round(u + v) + t
  return s;
}

double AngNormalize(double x) {
  using std::remainder;
  x = remainder(x, double(360)); return x != -180 ? x : 180;
}

double AngRound(double x) {
  using std::abs;
  static const double z = 1 / 16;
  if (x == 0) return 0;
  double y = abs(x);
  // The compiler mustn't "simplify" z - (z - y) to y
  y = y < z ? z - (z - y) : y;
  return x < 0 ? -y : y;
}

double AngDiff(double x, double y, double& e) {
  using std::remainder;
  double t, d = AngNormalize(sum(remainder(-x, double(360)),
                            remainder( y, double(360)), t));
  // Here y - x = d + t (mod 360), exactly, where d is in (-180,180] and
  // abs(t) <= eps (eps = 2^-45 for doubles).  The only case where the
  // addition of t takes the result outside the range (-180,180] is d = 180
  // and t > 0.  The case, d = -180 + eps, t = -eps, can't happen, since
  // sum would have returned the exact result in such a case (i.e., given t
  // = 0).
  return sum(d == 180 && t > 0 ? -180 : d, t, e);
}

// The coefficients C1[l] in the Fourier expansion of B1
void C1f(double eps, double c[]) {
  int nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER, nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  // Generated by Maxima on 2015-05-05 18:08:12-04:00
#if GEOGRAPHICLIB_GEODESIC_ORDER == 3
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 1
    3, -8, 16,
    // C1[2]/eps^2, polynomial in eps2 of order 0
    -1, 16,
    // C1[3]/eps^3, polynomial in eps2 of order 0
    -1, 48,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 4
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 1
    3, -8, 16,
    // C1[2]/eps^2, polynomial in eps2 of order 1
    1, -2, 32,
    // C1[3]/eps^3, polynomial in eps2 of order 0
    -1, 48,
    // C1[4]/eps^4, polynomial in eps2 of order 0
    -5, 512,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 5
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 2
    -1, 6, -16, 32,
    // C1[2]/eps^2, polynomial in eps2 of order 1
    1, -2, 32,
    // C1[3]/eps^3, polynomial in eps2 of order 1
    9, -16, 768,
    // C1[4]/eps^4, polynomial in eps2 of order 0
    -5, 512,
    // C1[5]/eps^5, polynomial in eps2 of order 0
    -7, 1280,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 6
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 2
    -1, 6, -16, 32,
    // C1[2]/eps^2, polynomial in eps2 of order 2
    -9, 64, -128, 2048,
    // C1[3]/eps^3, polynomial in eps2 of order 1
    9, -16, 768,
    // C1[4]/eps^4, polynomial in eps2 of order 1
    3, -5, 512,
    // C1[5]/eps^5, polynomial in eps2 of order 0
    -7, 1280,
    // C1[6]/eps^6, polynomial in eps2 of order 0
    -7, 2048,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 7
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 3
    19, -64, 384, -1024, 2048,
    // C1[2]/eps^2, polynomial in eps2 of order 2
    -9, 64, -128, 2048,
    // C1[3]/eps^3, polynomial in eps2 of order 2
    -9, 72, -128, 6144,
    // C1[4]/eps^4, polynomial in eps2 of order 1
    3, -5, 512,
    // C1[5]/eps^5, polynomial in eps2 of order 1
    35, -56, 10240,
    // C1[6]/eps^6, polynomial in eps2 of order 0
    -7, 2048,
    // C1[7]/eps^7, polynomial in eps2 of order 0
    -33, 14336,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 8
  static const double coeff[] = {
    // C1[1]/eps^1, polynomial in eps2 of order 3
    19, -64, 384, -1024, 2048,
    // C1[2]/eps^2, polynomial in eps2 of order 3
    7, -18, 128, -256, 4096,
    // C1[3]/eps^3, polynomial in eps2 of order 2
    -9, 72, -128, 6144,
    // C1[4]/eps^4, polynomial in eps2 of order 2
    -11, 96, -160, 16384,
    // C1[5]/eps^5, polynomial in eps2 of order 1
    35, -56, 10240,
    // C1[6]/eps^6, polynomial in eps2 of order 1
    9, -14, 4096,
    // C1[7]/eps^7, polynomial in eps2 of order 0
    -33, 14336,
    // C1[8]/eps^8, polynomial in eps2 of order 0
    -429, 262144,
  };
#else
#error "Bad value for GEOGRAPHICLIB_GEODESIC_ORDER"
#endif
  // GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(double) ==
                              // (nC1_*nC1_ + 7*nC1_ - 2*(nC1_/2)) / 4,
                              // "Coefficient array size mismatch in C1f");
  double
    eps2 = sq(eps),
    d = eps;
  int o = 0;
  for (int l = 1; l <= nC1_; ++l) { // l is index of C1p[l]
    int m = (nC1_ - l) / 2;         // order of polynomial in eps^2
    c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];
    o += m + 2;
    d *= eps;
  }
  // Post condition: o == sizeof(coeff) / sizeof(double)
}

// The coefficients C1p[l] in the Fourier expansion of B1p
void C1pf(double eps, double c[]) {
  // Generated by Maxima on 2015-05-05 18:08:12-04:00
#if GEOGRAPHICLIB_GEODESIC_ORDER == 3
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 1
    -9, 16, 32,
    // C1p[2]/eps^2, polynomial in eps2 of order 0
    5, 16,
    // C1p[3]/eps^3, polynomial in eps2 of order 0
    29, 96,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 4
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 1
    -9, 16, 32,
    // C1p[2]/eps^2, polynomial in eps2 of order 1
    -37, 30, 96,
    // C1p[3]/eps^3, polynomial in eps2 of order 0
    29, 96,
    // C1p[4]/eps^4, polynomial in eps2 of order 0
    539, 1536,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 5
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 2
    205, -432, 768, 1536,
    // C1p[2]/eps^2, polynomial in eps2 of order 1
    -37, 30, 96,
    // C1p[3]/eps^3, polynomial in eps2 of order 1
    -225, 116, 384,
    // C1p[4]/eps^4, polynomial in eps2 of order 0
    539, 1536,
    // C1p[5]/eps^5, polynomial in eps2 of order 0
    3467, 7680,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 6
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 2
    205, -432, 768, 1536,
    // C1p[2]/eps^2, polynomial in eps2 of order 2
    4005, -4736, 3840, 12288,
    // C1p[3]/eps^3, polynomial in eps2 of order 1
    -225, 116, 384,
    // C1p[4]/eps^4, polynomial in eps2 of order 1
    -7173, 2695, 7680,
    // C1p[5]/eps^5, polynomial in eps2 of order 0
    3467, 7680,
    // C1p[6]/eps^6, polynomial in eps2 of order 0
    38081, 61440,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 7
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 3
    -4879, 9840, -20736, 36864, 73728,
    // C1p[2]/eps^2, polynomial in eps2 of order 2
    4005, -4736, 3840, 12288,
    // C1p[3]/eps^3, polynomial in eps2 of order 2
    8703, -7200, 3712, 12288,
    // C1p[4]/eps^4, polynomial in eps2 of order 1
    -7173, 2695, 7680,
    // C1p[5]/eps^5, polynomial in eps2 of order 1
    -141115, 41604, 92160,
    // C1p[6]/eps^6, polynomial in eps2 of order 0
    38081, 61440,
    // C1p[7]/eps^7, polynomial in eps2 of order 0
    459485, 516096,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 8
  static const double coeff[] = {
    // C1p[1]/eps^1, polynomial in eps2 of order 3
    -4879, 9840, -20736, 36864, 73728,
    // C1p[2]/eps^2, polynomial in eps2 of order 3
    -86171, 120150, -142080, 115200, 368640,
    // C1p[3]/eps^3, polynomial in eps2 of order 2
    8703, -7200, 3712, 12288,
    // C1p[4]/eps^4, polynomial in eps2 of order 2
    1082857, -688608, 258720, 737280,
    // C1p[5]/eps^5, polynomial in eps2 of order 1
    -141115, 41604, 92160,
    // C1p[6]/eps^6, polynomial in eps2 of order 1
    -2200311, 533134, 860160,
    // C1p[7]/eps^7, polynomial in eps2 of order 0
    459485, 516096,
    // C1p[8]/eps^8, polynomial in eps2 of order 0
    109167851, 82575360,
  };
#else
#error "Bad value for GEOGRAPHICLIB_GEODESIC_ORDER"
#endif
  // GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(double) ==
                              // (nC1p_*nC1p_ + 7*nC1p_ - 2*(nC1p_/2)) / 4,
                              // "Coefficient array size mismatch in C1pf");
  int nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER, nC1p_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  double
    eps2 = sq(eps),
    d = eps;
  int o = 0;
  for (int l = 1; l <= nC1p_; ++l) { // l is index of C1p[l]
    int m = (nC1p_ - l) / 2;         // order of polynomial in eps^2
    c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];
    o += m + 2;
    d *= eps;
  }
  // Post condition: o == sizeof(coeff) / sizeof(double)
}

// The coefficients C2[l] in the Fourier expansion of B2
void C2f(double eps, double c[]) {
  // Generated by Maxima on 2015-05-05 18:08:12-04:00
#if GEOGRAPHICLIB_GEODESIC_ORDER == 3
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 1
    1, 8, 16,
    // C2[2]/eps^2, polynomial in eps2 of order 0
    3, 16,
    // C2[3]/eps^3, polynomial in eps2 of order 0
    5, 48,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 4
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 1
    1, 8, 16,
    // C2[2]/eps^2, polynomial in eps2 of order 1
    1, 6, 32,
    // C2[3]/eps^3, polynomial in eps2 of order 0
    5, 48,
    // C2[4]/eps^4, polynomial in eps2 of order 0
    35, 512,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 5
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 2
    1, 2, 16, 32,
    // C2[2]/eps^2, polynomial in eps2 of order 1
    1, 6, 32,
    // C2[3]/eps^3, polynomial in eps2 of order 1
    15, 80, 768,
    // C2[4]/eps^4, polynomial in eps2 of order 0
    35, 512,
    // C2[5]/eps^5, polynomial in eps2 of order 0
    63, 1280,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 6
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 2
    1, 2, 16, 32,
    // C2[2]/eps^2, polynomial in eps2 of order 2
    35, 64, 384, 2048,
    // C2[3]/eps^3, polynomial in eps2 of order 1
    15, 80, 768,
    // C2[4]/eps^4, polynomial in eps2 of order 1
    7, 35, 512,
    // C2[5]/eps^5, polynomial in eps2 of order 0
    63, 1280,
    // C2[6]/eps^6, polynomial in eps2 of order 0
    77, 2048,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 7
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 3
    41, 64, 128, 1024, 2048,
    // C2[2]/eps^2, polynomial in eps2 of order 2
    35, 64, 384, 2048,
    // C2[3]/eps^3, polynomial in eps2 of order 2
    69, 120, 640, 6144,
    // C2[4]/eps^4, polynomial in eps2 of order 1
    7, 35, 512,
    // C2[5]/eps^5, polynomial in eps2 of order 1
    105, 504, 10240,
    // C2[6]/eps^6, polynomial in eps2 of order 0
    77, 2048,
    // C2[7]/eps^7, polynomial in eps2 of order 0
    429, 14336,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER == 8
  static const double coeff[] = {
    // C2[1]/eps^1, polynomial in eps2 of order 3
    41, 64, 128, 1024, 2048,
    // C2[2]/eps^2, polynomial in eps2 of order 3
    47, 70, 128, 768, 4096,
    // C2[3]/eps^3, polynomial in eps2 of order 2
    69, 120, 640, 6144,
    // C2[4]/eps^4, polynomial in eps2 of order 2
    133, 224, 1120, 16384,
    // C2[5]/eps^5, polynomial in eps2 of order 1
    105, 504, 10240,
    // C2[6]/eps^6, polynomial in eps2 of order 1
    33, 154, 4096,
    // C2[7]/eps^7, polynomial in eps2 of order 0
    429, 14336,
    // C2[8]/eps^8, polynomial in eps2 of order 0
    6435, 262144,
  };
#else
#error "Bad value for GEOGRAPHICLIB_GEODESIC_ORDER"
#endif
  // GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(double) ==
                              // (nC2_*nC2_ + 7*nC2_ - 2*(nC2_/2)) / 4,
                              // "Coefficient array size mismatch in C2f");
  double
    eps2 = sq(eps),
    d = eps;
  int o = 0;
  for (int l = 1; l <= nC2_; ++l) { // l is index of C2[l]
    int m = (nC2_ - l) / 2;         // order of polynomial in eps^2
    c[l] = d * polyval(m, coeff + o, eps2) / coeff[o + m + 1];
    o += m + 2;
    d *= eps;
  }
  // Post condition: o == sizeof(coeff) / sizeof(double)
}


// The scale factor A2-1 = mean value of (d/dsigma)I2 - 1
double A2m1f(double eps) {
  // Generated by Maxima on 2015-05-29 08:09:47-04:00
#if GEOGRAPHICLIB_GEODESIC_ORDER/2 == 1
  static const double coeff[] = {
    // (eps+1)*A2-1, polynomial in eps2 of order 1
    -3, 0, 4,
  };  // count = 3
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 2
  static const double coeff[] = {
    // (eps+1)*A2-1, polynomial in eps2 of order 2
    -7, -48, 0, 64,
  };  // count = 4
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 3
  static const double coeff[] = {
    // (eps+1)*A2-1, polynomial in eps2 of order 3
    -11, -28, -192, 0, 256,
  };  // count = 5
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 4
  static const double coeff[] = {
    // (eps+1)*A2-1, polynomial in eps2 of order 4
    -375, -704, -1792, -12288, 0, 16384,
  };  // count = 6
#else
#error "Bad value for GEOGRAPHICLIB_GEODESIC_ORDER"
#endif
  // GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(double) == nA2_/2 + 2,
                              // "Coefficient array size mismatch in A2m1f");
  int nA2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  int m = nA2_/2;
  double t = polyval(m, coeff, sq(eps)) / coeff[m + 1];
  return (t - eps) / (1 + eps);
}


// The scale factor A1-1 = mean value of (d/dsigma)I1 - 1
double A1m1f(double eps) {
  // Generated by Maxima on 2015-05-05 18:08:12-04:00
#if GEOGRAPHICLIB_GEODESIC_ORDER/2 == 1
  static const double coeff[] = {
    // (1-eps)*A1-1, polynomial in eps2 of order 1
    1, 0, 4,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 2
  static const double coeff[] = {
    // (1-eps)*A1-1, polynomial in eps2 of order 2
    1, 16, 0, 64,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 3
  static const double coeff[] = {
    // (1-eps)*A1-1, polynomial in eps2 of order 3
    1, 4, 64, 0, 256,
  };
#elif GEOGRAPHICLIB_GEODESIC_ORDER/2 == 4
  static const double coeff[] = {
    // (1-eps)*A1-1, polynomial in eps2 of order 4
    25, 64, 256, 4096, 0, 16384,
  };
#else
#error "Bad value for GEOGRAPHICLIB_GEODESIC_ORDER"
#endif
  // GEOGRAPHICLIB_STATIC_ASSERT(sizeof(coeff) / sizeof(double) == nA1_/2 + 2,
  //                             "Coefficient array size mismatch in A1m1f");
  int nA1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  int m = nA1_/2;
  double t = polyval(m, coeff, sq(eps)) / coeff[m + 1];
  return (t + eps) / (1 - eps);
}

double SinCosSeries(bool sinp,
                                  double sinx, double cosx,
                                  const double c[], int n) {
  // Evaluate
  // y = sinp ? sum(c[i] * sin( 2*i    * x), i, 1, n) :
  //            sum(c[i] * cos((2*i+1) * x), i, 0, n-1)
  // using Clenshaw summation.  N.B. c[0] is unused for sin series
  // Approx operation count = (n + 5) mult and (2 * n + 2) add
  c += (n + sinp);            // Point to one beyond last element
  double
    ar = 2 * (cosx - sinx) * (cosx + sinx), // 2 * cos(2 * x)
    y0 = n & 1 ? *--c : 0, y1 = 0;          // accumulators for sum
  // Now n is even
  n /= 2;
  while (n--) {
    // Unroll loop x 2, so accumulators return to their original role
    y1 = ar * y0 - y1 + *--c;
    y0 = ar * y1 - y0 + *--c;
  }
  return sinp
    ? 2 * sinx * cosx * y0    // sin(2 * x) * y0
    : cosx * (y0 - y1);       // cos(x) * (y0 - y1)
}

// GeodesicLine Geodesic::Line(double lat1, double lon1, double azi1,
//                             unsigned caps) const {
//   return GeodesicLine(*this, lat1, lon1, azi1, caps);
// }

void Lengths(double eps, double sig12,
                       double ssig1, double csig1, double dn1,
                       double ssig2, double csig2, double dn2,
                       double cbet1, double cbet2, unsigned outmask,
                       double& s12b, double& m12b, double& m0,
                       double& M12, double& M21,
                       // Scratch area of the right size
                       double Ca[], int nC2_, double _f) {
  // Return m12b = (reduced length)/_b; also calculate s12b = distance/_b,
  // and m0 = coefficient of secular term in expression for reduced length.
  double _ep2 = (_f * (2 - _f)) / sq(1 - _f);
  outmask &= OUT_MASK;
  // outmask & DISTANCE: set s12b
  // outmask & REDUCEDLENGTH: set m12b & m0
  // outmask & GEODESICSCALE: set M12 & M21

  int nC1_ = GEOGRAPHICLIB_GEODESIC_ORDER;
  double m0x = 0, J12 = 0, A1 = 0, A2 = 0;
  double Cb[nC2_ + 1];
  if (outmask & (DISTANCE | REDUCEDLENGTH | GEODESICSCALE)) {
    A1 = A1m1f(eps);
    C1f(eps, Ca);
    if (outmask & (REDUCEDLENGTH | GEODESICSCALE)) {
      A2 = A2m1f(eps);
      C2f(eps, Cb);
      m0x = A1 - A2;
      A2 = 1 + A2;
    }
    A1 = 1 + A1;
  }
  if (outmask & DISTANCE) {
    double B1 = SinCosSeries(true, ssig2, csig2, Ca, nC1_) -
      SinCosSeries(true, ssig1, csig1, Ca, nC1_);
    // Missing a factor of _b
    s12b = A1 * (sig12 + B1);
    if (outmask & (REDUCEDLENGTH | GEODESICSCALE)) {
      double B2 = SinCosSeries(true, ssig2, csig2, Cb, nC2_) -
        SinCosSeries(true, ssig1, csig1, Cb, nC2_);
      J12 = m0x * sig12 + (A1 * B1 - A2 * B2);
    }
  } else if (outmask & (REDUCEDLENGTH | GEODESICSCALE)) {
    // Assume here that nC1_ >= nC2_
    for (int l = 1; l <= nC2_; ++l)
      Cb[l] = A1 * Ca[l] - A2 * Cb[l];
    J12 = m0x * sig12 + (SinCosSeries(true, ssig2, csig2, Cb, nC2_) -
                         SinCosSeries(true, ssig1, csig1, Cb, nC2_));
  }
  if (outmask & REDUCEDLENGTH) {
    m0 = m0x;
    // Missing a factor of _b.
    // Add parens around (csig1 * ssig2) and (ssig1 * csig2) to ensure
    // accurate cancellation in the case of coincident points.
    m12b = dn2 * (csig1 * ssig2) - dn1 * (ssig1 * csig2) -
      csig1 * csig2 * J12;
  }
  if (outmask & GEODESICSCALE) {
    double csig12 = csig1 * csig2 + ssig1 * ssig2;
    double t = _ep2 * (cbet1 - cbet2) * (cbet1 + cbet2) / (dn1 + dn2);
    M12 = csig12 + (t * ssig2 - csig2 * J12) * ssig1 / dn1;
    M21 = csig12 - (t * ssig1 - csig1 * J12) * ssig2 / dn2;
  }
}

double Astroid(double x, double y) {
  // Solve k^4+2*k^3-(x^2+y^2-1)*k^2-2*y^2*k-y^2 = 0 for positive root k.
  // This solution is adapted from Geocentric::Reverse.
  double k;
  double
    p = sq(x),
    q = sq(y),
    r = (p + q - 1) / 6;
  if ( !(q == 0 && r <= 0) ) {
    double
      // Avoid possible division by zero when r = 0 by multiplying equations
      // for s and t by r^3 and r, resp.
      S = p * q / 4,            // S = r^3 * s
      r2 = sq(r),
      r3 = r * r2,
      // The discriminant of the quadratic equation for T3.  This is zero on
      // the evolute curve p^(1/3)+q^(1/3) = 1
      disc = S * (S + 2 * r3);
    double u = r;
    if (disc >= 0) {
      double T3 = S + r3;
      // Pick the sign on the sqrt to maximize abs(T3).  This minimizes loss
      // of precision due to cancellation.  The result is unchanged because
      // of the way the T is used in definition of u.
      T3 += T3 < 0 ? -sqrt(disc) : sqrt(disc); // T3 = (r * t)^3
      // N.B. cbrt always returns the double root.  cbrt(-8) = -2.
      double T = cbrt(T3); // T = r * t
      // T can be zero; but then r2 / T -> 0.
      u += T + (T != 0 ? r2 / T : 0);
    } else {
      // T is complex, but the way u is defined the result is double.
      double ang = atan2(sqrt(-disc), -(S + r3));
      // There are three possible cube roots.  We choose the root which
      // avoids cancellation.  Note that disc < 0 implies that r < 0.
      u += 2 * r * cos(ang / 3);
    }
    double
      v = sqrt(sq(u) + q),    // guaranteed positive
      // Avoid loss of accuracy when u < 0.
      uv = u < 0 ? q / (v - u) : u + v, // u+v, guaranteed positive
      w = (uv - q) / (2 * v);           // positive?
    // Rearrange expression for k to avoid loss of accuracy due to
    // subtraction.  Division by 0 not possible because uv > 0, w >= 0.
    k = uv / (sqrt(uv + sq(w)) + w);   // guaranteed positive
  } else {               // q == 0 && r <= 0
    // y = 0 with |x| <= 1.  Handle this case directly.
    // for y small, positive root is k = abs(y)/sqrt(1-x^2)
    k = 0;
  }
  return k;
}

double InverseStart(double sbet1, double cbet1, double dn1,
                                double sbet2, double cbet2, double dn2,
                                double lam12, double slam12, double clam12,
                                double& salp1, double& calp1,
                                // Only updated if return val >= 0
                                double& salp2, double& calp2,
                                // Only updated for short lines
                                double& dnm,
                                // Scratch area of the right size
                                double Ca[],
                                double _ep2,
                                double _f,
                                double _f1) {
double
  _n = _f / ( 2 - _f),
  tol2_ = std::sqrt(std::numeric_limits<double>::epsilon()),
  _etol2 = double(0.1) * tol2_ /
               std::sqrt( std::max(double(0.001), std::abs(_f)) * std::min(double(1), 1 - _f/2) / 2 );

// Return a starting point for Newton's method in salp1 and calp1 (function
// value is -1).  If Newton's method doesn't need to be used, return also
// salp2 and calp2 and function value is sig12.
double
  sig12 = -1,               // Return value
  // bet12 = bet2 - bet1 in [0, pi); bet12a = bet2 + bet1 in (-pi, 0]
  sbet12 = sbet2 * cbet1 - cbet2 * sbet1,
  cbet12 = cbet2 * cbet1 + sbet2 * sbet1;
#if defined(__GNUC__) && __GNUC__ == 4 && \
(__GNUC_MINOR__ < 6 || defined(__MINGW32__))
// Volatile declaration needed to fix inverse cases
// 88.202499451857 0 -88.202499451857 179.981022032992859592
// 89.262080389218 0 -89.262080389218 179.992207982775375662
// 89.333123580033 0 -89.333123580032997687 179.99295812360148422
// which otherwise fail with g++ 4.4.4 x86 -O3 (Linux)
// and g++ 4.4.0 (mingw) and g++ 4.6.1 (tdm mingw).
double sbet12a;
{
  volatile double xx1 = sbet2 * cbet1;
  volatile double xx2 = cbet2 * sbet1;
  sbet12a = xx1 + xx2;
}
#else
double sbet12a = sbet2 * cbet1 + cbet2 * sbet1;
#endif
bool shortline = cbet12 >= 0 && sbet12 < double(0.5) &&
  cbet2 * lam12 < double(0.5);
double somg12, comg12;
if (shortline) {
  double sbetm2 = sq(sbet1 + sbet2);
  // sin((bet1+bet2)/2)^2
  // =  (sbet1 + sbet2)^2 / ((sbet1 + sbet2)^2 + (cbet1 + cbet2)^2)
  sbetm2 /= sbetm2 + sq(cbet1 + cbet2);
  dnm = sqrt(1 + _ep2 * sbetm2);
  double omg12 = lam12 / (_f1 * dnm);
  somg12 = sin(omg12); comg12 = cos(omg12);
} else {
  somg12 = slam12; comg12 = clam12;
}

salp1 = cbet2 * somg12;
calp1 = comg12 >= 0 ?
  sbet12 + cbet2 * sbet1 * sq(somg12) / (1 + comg12) :
  sbet12a - cbet2 * sbet1 * sq(somg12) / (1 - comg12);

double
  ssig12 = hypot(salp1, calp1),
  csig12 = sbet1 * sbet2 + cbet1 * cbet2 * comg12;

if (shortline && ssig12 < _etol2) {
  // doublely short lines
  salp2 = cbet1 * somg12;
  calp2 = sbet12 - cbet1 * sbet2 *
    (comg12 >= 0 ? sq(somg12) / (1 + comg12) : 1 - comg12);
  norm(salp2, calp2);
  // Set return value
  sig12 = atan2(ssig12, csig12);
} else if (abs(_n) > double(0.1) || // Skip astroid calc if too eccentric
           csig12 >= 0 ||
           ssig12 >= 6 * abs(_n) * pi() * sq(cbet1)) {
  // Nothing to do, zeroth order spherical approximation is OK
} else {
  // Scale lam12 and bet2 to x, y coordinate system where antipodal point
  // is at origin and singular point is at y = 0, x = -1.
  double y, lamscale, betscale;
  // Volatile declaration needed to fix inverse case
  // 56.320923501171 0 -56.320923501171 179.664747671772880215
  // which otherwise fails with g++ 4.4.4 x86 -O3
  volatile double x;
  double lam12x = atan2(-slam12, -clam12); // lam12 - pi
  if (_f >= 0) {            // In fact f == 0 does not get here
    // x = dlong, y = dlat
    {
      double
        k2 = sq(sbet1) * _ep2,
        eps = k2 / (2 * (1 + sqrt(1 + k2)) + k2);
      lamscale = _f * cbet1 * A3f(eps) * pi();
    }
    betscale = lamscale * cbet1;

    x = lam12x / lamscale;
    y = sbet12a / betscale;
  } else {                  // _f < 0
    // x = dlat, y = dlong
    double
      cbet12a = cbet2 * cbet1 - sbet2 * sbet1,
      bet12a = atan2(sbet12a, cbet12a);
    double m12b, m0, dummy;
    // In the case of lon12 = 180, this repeats a calculation made in
    // Inverse.
    int nC2_ = GEOGRAPHICLIB_GEODESIC_ORDER;
    
    Lengths(_n, pi() + bet12a,
            sbet1, -cbet1, dn1, sbet2, cbet2, dn2,
            cbet1, cbet2,
            REDUCEDLENGTH, dummy, m12b, m0, dummy, dummy, Ca, nC2_, _f);
    x = -1 + m12b / (cbet1 * cbet2 * m0 * pi());
    betscale = x < -double(0.01) ? sbet12a / x :
      -_f * sq(cbet1) * pi();
    lamscale = betscale / cbet1;
    y = lam12x / lamscale;
  }

  double tol1_ = 200 * std::numeric_limits<double>::epsilon(),
         xthresh_ = 1000 * tol2_;
  if (y > -tol1_ && x > -1 - xthresh_) {
    // strip near cut
    // Need double(x) here to cast away the volatility of x for min/max
    if (_f >= 0) {
      salp1 = std::min(double(1), -double(x)); calp1 = - sqrt(1 - sq(salp1));
    } else {
      calp1 = std::max(double(x > -tol1_ ? 0 : -1), double(x));
      salp1 = std::sqrt(1 - sq(calp1));
    }
  } else {
    // Estimate alp1, by solving the astroid problem.
    //
    // Could estimate alpha1 = theta + pi/2, directly, i.e.,
    //   calp1 = y/k; salp1 = -x/(1+k);  for _f >= 0
    //   calp1 = x/(1+k); salp1 = -y/k;  for _f < 0 (need to check)
    //
    // However, it's better to estimate omg12 from astroid and use
    // spherical formula to compute alp1.  This reduces the mean number of
    // Newton iterations for astroid cases from 2.24 (min 0, max 6) to 2.12
    // (min 0 max 5).  The changes in the number of iterations are as
    // follows:
    //
    // change percent
    //    1       5
    //    0      78
    //   -1      16
    //   -2       0.6
    //   -3       0.04
    //   -4       0.002
    //
    // The histogram of iterations is (m = number of iterations estimating
    // alp1 directly, n = number of iterations estimating via omg12, total
    // number of trials = 148605):
    //
    //  iter    m      n
    //    0   148    186
    //    1 13046  13845
    //    2 93315 102225
    //    3 36189  32341
    //    4  5396      7
    //    5   455      1
    //    6    56      0
    //
    // Because omg12 is near pi, estimate work with omg12a = pi - omg12
    double k = Astroid(x, y);
    double
      omg12a = lamscale * ( _f >= 0 ? -x * k/(1 + k) : -y * (1 + k)/k );
    somg12 = sin(omg12a); comg12 = -cos(omg12a);
    // Update spherical estimate of alp1 using omg12 instead of lam12
    salp1 = cbet2 * somg12;
    calp1 = sbet12a - cbet2 * sbet1 * sq(somg12) / (1 - comg12);
  }
}
// Sanity check on starting guess.  Backwards check allows NaN through.
if (!(salp1 <= 0))
  norm(salp1, calp1);
else {
  salp1 = 1; calp1 = 0;
}
return sig12;
}

double Lambda12(double sbet1, double cbet1, double dn1,
                              double sbet2, double cbet2, double dn2,
                              double salp1, double calp1,
                              double slam120, double clam120,
                              double& salp2, double& calp2,
                              double& sig12,
                              double& ssig1, double& csig1,
                              double& ssig2, double& csig2,
                              double& eps, double& domg12,
                              bool diffp, double& dlam12,
                              // Scratch area of the right size
                              double Ca[], double _ep2, double tiny_, double _f, double _f1) {
  if (sbet1 == 0 && calp1 == 0)
    // Break degeneracy of equatorial line.  This case has already been
    // handled.
    calp1 = -tiny_;

  double
    // sin(alp1) * cos(bet1) = sin(alp0)
    salp0 = salp1 * cbet1,
    calp0 = hypot(calp1, salp1 * sbet1); // calp0 > 0

  double somg1, comg1, somg2, comg2, somg12, comg12, lam12;
  // tan(bet1) = tan(sig1) * cos(alp1)
  // tan(omg1) = sin(alp0) * tan(sig1) = tan(omg1)=tan(alp1)*sin(bet1)
  ssig1 = sbet1; somg1 = salp0 * sbet1;
  csig1 = comg1 = calp1 * cbet1;
  norm(ssig1, csig1);
  // norm(somg1, comg1); -- don't need to normalize!

  // Enforce symmetries in the case abs(bet2) = -bet1.  Need to be careful
  // about this case, since this can yield singularities in the Newton
  // iteration.
  // sin(alp2) * cos(bet2) = sin(alp0)
  salp2 = cbet2 != cbet1 ? salp0 / cbet2 : salp1;
  // calp2 = sqrt(1 - sq(salp2))
  //       = sqrt(sq(calp0) - sq(sbet2)) / cbet2
  // and subst for calp0 and rearrange to give (choose positive sqrt
  // to give alp2 in [0, pi/2]).
  calp2 = cbet2 != cbet1 || abs(sbet2) != -sbet1 ?
    sqrt(sq(calp1 * cbet1) +
         (cbet1 < -sbet1 ?
          (cbet2 - cbet1) * (cbet1 + cbet2) :
          (sbet1 - sbet2) * (sbet1 + sbet2))) / cbet2 :
    abs(calp1);
  // tan(bet2) = tan(sig2) * cos(alp2)
  // tan(omg2) = sin(alp0) * tan(sig2).
  ssig2 = sbet2; somg2 = salp0 * sbet2;
  csig2 = comg2 = calp2 * cbet2;
  norm(ssig2, csig2);
  // norm(somg2, comg2); -- don't need to normalize!

  // sig12 = sig2 - sig1, limit to [0, pi]
  sig12 = atan2(std::max(double(0), csig1 * ssig2 - ssig1 * csig2),
                             csig1 * csig2 + ssig1 * ssig2);

  // omg12 = omg2 - omg1, limit to [0, pi]
  somg12 = std::max(double(0), comg1 * somg2 - somg1 * comg2);
  comg12 =              comg1 * comg2 + somg1 * somg2;
  // eta = omg12 - lam120
  double eta = atan2(somg12 * clam120 - comg12 * slam120,
                   comg12 * clam120 + somg12 * slam120);
  double B312;
  double k2 = sq(calp0) * _ep2;
  eps = k2 / (2 * (1 + sqrt(1 + k2)) + k2);
  C3f(eps, Ca);
  B312 = (SinCosSeries(true, ssig2, csig2, Ca, nC3_-1) -
          SinCosSeries(true, ssig1, csig1, Ca, nC3_-1));
  domg12 = -_f * A3f(eps) * salp0 * (sig12 + B312);
  lam12 = eta + domg12;

  if (diffp) {
    if (calp2 == 0)
      dlam12 = - 2 * _f1 * dn1 / sbet1;
    else {
      double dummy;
      Lengths(eps, sig12, ssig1, csig1, dn1, ssig2, csig2, dn2,
              cbet1, cbet2, REDUCEDLENGTH,
              dummy, dlam12, dummy, dummy, dummy, Ca, nC2_, _f);
      dlam12 *= _f1 / (calp2 * cbet2);
    }
  }

  return lam12;
}
